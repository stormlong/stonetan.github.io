<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构-图]]></title>
    <url>%2F2019%2F03%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[我们平常都用到微信，QQ，微博等社交软件，但是你有没有考虑过这些社交软件的好友关系是怎么存储的？这就是我们今天要介绍的数据结构–图。 如何理解 图图（Graph）是一种更加复杂的非线性表结构。图中的元素我们就叫作 顶点（vertex） 。图中的一个顶点可以与任意其他顶点建立连接关系。我们把这种建立的关系叫作边（edge）。 现实生活中微信好友之间的关系就用图这种数据结构来存储的。每一个用户就是一个顶点，如果两个用户之间互相加好友，就在这两个顶点之间建立一条边。每个用户有多少个好友，对应到图中就是顶点的度（degree）。就是跟顶点相连接的边的条数。 微博的社交关系跟微信有些不一样，微博允许单方向关注。也就是 A 关注了 B , B 可以不用关注 A ,这时我们可以用带 “方向” 的图来表示。 如果用户 A 关注了用户 B，我们就在图中画一条从 A 到 B 的带箭头的边，来表示边的方向。如果用户 A 和用户 B 互相关注了，再画一条从 B 指向 A 的边。我们把这种边有方向的图叫作”有向图”。我们把边没有方向的图就叫作”无向图”。 在有向图中，可以把 “度”，分为 入度 和 出度 。 顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。对应到微博的例子，入度就表示有多少粉丝，出度就表示关注了多少人。 QQ的社交关系就比较复杂一点。QQ有一个亲密度这样的功能，如果两人之间经常来往，那么亲密度就会比较高，如果不经常来往，亲密度就比较低，这就是 带权图 。 在带权图中，每条边都有一个权重（weight） ，我们可以通过这个权重来表示 QQ 好友间的亲密度。 如何在内存中存储图这种数据结构呢？ 邻接矩阵存储方法邻接矩阵底层是一个二维数组。对于无向图来说，如果如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j] 和 A[j][i] 标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j] 标记为 1。如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i] 标记为 1。对于带权图，数组中就存储相应的权重。 用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。对于无向图来说，如果 A[i][j] 等于 1，那 A[j][i] 也肯定等1。实际上，我们只需要存储一个就可以了。也就是说，无向图的二维数组中，如果我们将其用对角线划分为上下两部分，那我们只需要利用上面或者下面这样一半的空间就足够了，另外一半白白浪费掉了。 如果我们存储的是 稀疏图（Sparse Matrix） ，就是顶点很多，每个顶点的边并不多，这个时候再用邻接矩阵存储就更浪费空间了。比如，微信有几亿用户，如果每一个用户就是一个顶点，但是用户的好友一般就三百多个，如果用邻接矩阵存储，绝大部分的存储空间都被浪费了。 但这也并不是说，邻接矩阵的存储方法就完全没有优点。邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。 邻接表存储方法每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。 邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。 如果我们要确定，是否存在一条从顶点 2 到顶点 4 的边，那我们就要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4。所以，比起邻接矩阵的存储方式，在邻接表中查询两个顶点之间的关系就没那么高效了。 逆邻接表我们知道可以用邻接表存储关注用户，也就是你关注了那些人，但是对方怎么知道你关注了他呢，也就是他想知道自己的粉丝有谁，这时候就需要 逆邻接表 来表示了。 逆邻接表每一个顶点作为链表的头节点，后继节点所存储的是能够直接达到该顶点的相邻顶点。 如果要查找某个用户关注了哪些用户，我们可以在邻接表中查找；如果要查找某个用户被哪些用户关注了，我们从逆邻接表中查找。 十字链表每一个图都要存储 邻接表和逆邻接表，有些麻烦，我们可以用 十字链表 来存储。 十字链表 大概示意图 十字链表的每一个顶点，都是两个链表的根节点，其中一个链表存储着该顶点能到达的相邻顶点，另一个链表存储着能到达该顶点的相邻节点。 不过，上图只是一个便于理解的示意图，我们没有必要把链表的节点都重复存储两次。在优化之后的十字链表中，链表的每一个节点不再是顶点，而是一条边，里面包含起止顶点的下标。 优化之后的十字链表 图中每一条带有蓝色箭头的链表，存储着从顶点出发的边；每一条带有橙色箭头的链表，存储着进入顶点的边。 总结 根据图的边是否有方向，可分为有向图和无向图。根据图的边是否有权重，可分为带权图和无权图。当然，也可以把两个维度结合起来描述，比如有向带权图，无向无权图等等。 除此之外，我们还学习了图的两个主要的存储方式：邻接矩阵和邻接表。邻接矩阵优点是查询效率高，缺点是浪费空间。邻接表存储节省空间，但是链表查找不方便。 对于微博的关注与粉丝 的查找，我们可以采用 十字链表 这种数据结构来存储。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdk1.8新特性]]></title>
    <url>%2F2019%2F03%2F24%2Fjdk1-8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Java 8 新特性Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。 Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。 新特性Java8 新增了非常多的特性，我们主要讨论以下几个： Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。 方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。 新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。 Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。 Date Time API − 加强对日期与时间的处理。 Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。 Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。 Java 8 Lambda 表达式Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 使用 Lambda 表达式可以使代码变的更加简洁紧凑。 语法lambda 表达式的语法格式如下： (parameters) -expression 或 (parameters) -&gt;{ statements; } 以下是lambda表达式的重要特征: 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。 可选的大括号：如果主体包含了一个语句，就不需要使用大括号。 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。 变量作用域lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。]]></content>
      <categories>
        <category>jdk1.8新特性</category>
      </categories>
      <tags>
        <tag>jdk1.8新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网新技术(二)]]></title>
    <url>%2F2019%2F03%2F16%2F%E4%BA%92%E8%81%94%E7%BD%91%E6%96%B0%E6%8A%80%E6%9C%AF-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[这篇文章接着介绍一些新技术。 分布式搜索服务ElasticsearchElasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，基于Lucene的搜索服务器。 分布式实时文件存储，并将每一个字段都编入索引，使其可以被搜索。 实时分析的分布式搜索引擎。 可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。 地址：https://github.com/elastic/elasticsearch 大数据存储MongoDBMongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。 Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 消息中间件RabbitMQAMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。 消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。 AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。 RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗 KafkaKafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。 Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像Hadoop一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息。 云存储oss对象存储服务（Object Storage Service，简称 OSS）为您提供基于网络的数据存取服务。使用 OSS，您可以通过网络随时存储和调用包括文本、图片、音频和视频等在内的各种非结构化数据文件。 OSS可用于图片、音视频、日志等海量文件的存储。各种终端设备、Web网站程序、移动应用可以直接向OSS写入或读取数据。OSS支持流式写入和文件写入两种方式。 利用BGP带宽，OSS可以实现超低延时的数据直接下载。OSS也可以配合阿里云CDN加速服务，为图片、音视频、移动应用的更新分发提供最佳体验。 上传文件到OSS后，可以配合媒体处理服务和图片处理服务进行云端的数据处理。 java爬虫WebMagicWebMagic是一个简单灵活的Java爬虫框架。基于WebMagic，你可以快速开发出一个高效、易维护的爬虫。 简单的API，可快速上手 模块化的结构，可轻松扩展 提供多线程和分布式支持 人工智能DL4J用于JVM的开源，分布式，深度学习库. Eclipse Deeplearning4j是一个开源的，分布式的Java和Scala深度学习项目，由位于旧金山的商业智能和企业软件公司Skymind的人员带头。我们是一个由数据科学家，深度学习专家，Java系统工程师和半感知机器人组成的团队。 DL4J利用最新的分布式计算框架，包括Apache Spark和Hadoop来加速培训。在多GPU上，它在性能上等于Caffe。 这些库是完全开源的Apache 2.0，由开发人员社区和Skymind团队维护。 Deeplearning4j是用Java编写的，与任何JVM语言兼容，例如Scala，Clojure或Kotlin。底层计算是用C，C ++和Cuda编写的。Keras将作为Python API。 工作流ActivitiActiviti是领先的轻量级，以Java为中心的开源BPMN引擎，支持实际的流程自动化需求。 Activiti Cloud现在是新一代的业务自动化平台，提供一组旨在在分布式基础架构上运行的云原生构建块。 Activiti是由Alfresco软件发布的业务流程管理（BPM）框架，它是覆盖了业务流程管理、工作流、服务协作等领域的一个开源的、灵活的、易扩展的可执行流程语言框架。 Activiti基于Apache许可的开源BPM平台，创始人Tom Baeyens是JBoss jBPM的项目架构师，它特色是提供了eclipse插件，开发人员可以通过插件直接绘画出业务流程图。 人脸识别百度云AI基于深度学习的人脸识别方案，准确识别图片中的人脸信息，提供人脸属性识别、关键点定位、人脸1：1比对、人脸1：N识别、活体检测等能力。 微服务开发ServiceCombApache ServiceComb开箱即用、高性能、兼容流行生态、支持多语言的一站式开源微服务解决方案。 CSE微服务引擎（Cloud Service Engine）提供高性能微服务框架和一站式服务注册、服务治理、动态配置和分布式事务管理控制台，帮助用户实现微服务应用的快速开发和高可用运维； 支持ServiceComb、Spring Cloud和Service Mesh运行环境。 CSE(Cloud Service Engine)是一款华为云推出的微服务引擎，基于华为公司的大型系统微服务化积累的最佳实践构件，提供了微服务SDK,服务注册,配置和治理中心，帮助开发人员实现微服务应用的快速构建、治理运维。 CSE Mesher是Service Mesh模式的一种实现，将负载均衡、服务发现、熔断、运行时动态路由等能力抽象成将一层透明网络代理。正因为其作为独立运行透明代理的特点，CSE Mesher可以使得多种编程语言的应用，如PHP, .NET, NodeJS都能够快速转向微服务或者云原生应用，开发者无需修改原有的业务代码，以一种自然的机制扩展应用负载，自由混编，并因地制宜选择虚拟机或容器部署。 微服务治理华为云paas平台FusionStage是在大规模高可靠的云服务和大量高性能互联网应用的驱动下产生的新一代软件开发、集成、管理和运维的PaaS平台，提供企业应用真正云化能力，支撑企业产品和服务实施云化改造，并构建Cloud-Native云原生应用和服务。FusionStage适用于金融、政务、电信等众多行业。 海量容器秒级弹性伸缩，应用缩容不中断业务，按需分配资源，降低应用成本 应用快速上线，运维自动化 支持多语言（Java、C/C++、GO等）应用互通，异构主流IaaS，兼容主流计算框架 应用毫秒级通信时延，亿级消息堆积、千万级并发请求响应，集群联邦万级节点管理 解决用户应用的容器化，提升弹性伸缩的能力以及资源利用率：通常包含应用调度和资源管理框架、开发流水线（可选）、微服务框架（可选）等。 解决用户应用开发、集成、管理和运维一体化的平台，提升应用资源利用率、打通DevOps的全流程：通常包含应用调度和资源管理框架、开发流水线（可选）、微服务框架（可选）和中间件（可选）等。 服务端渲染(SSR)NuxtNuxt就是基于Vue的一个应用框架，采用服务端渲染，让你的SPA应用(Vue)也可以拥有SEO Nuxt最受欢迎的模式。使用SSR（也称为“通用”或“同构”模式），Node.js服务器将用于将基于Vue组件的HTML传送到客户端而不是纯JavaScript。使用SSR将带来大量的SEO提升，更好的用户体验和更多的机会（与传统的Vue SPA相比）。 Nuxt.js支持基于您的Vue应用程序生成静态网站。它是“两全其美”，因为您不需要服务器但仍然具有SEO优势，因为Nuxt将预渲染所有页面并包含必要的HTML。此外，您可以轻松地将生成的页面部署到Netlify或GitHub页面。 前后端分离API模拟Mock.jsMock.js是一个模拟数据生成器，可以帮助前端开发和原型分离后端进度，并减少一些单调，特别是在编写自动化测试时。 根据数据模板生成模拟数据 为ajax请求提供请求/响应模拟 微服务持续集成JenkinsJenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 Jenkins功能包括： 1、持续的软件版本发布/测试项目。 2、监控外部调用执行的工作。 jenkins是一个广泛用于持续构建的可视化web工具，持续构建说得更直白点，就是各种项目的”自动化”编译、打包、分发部署。jenkins可以很好的支持各种语言（比如：java, c#, php等）的项目构建，也完全兼容ant、maven、gradle等多种第三方构建工具，同时跟svn、git能无缝集成，也支持直接与知名源代码托管网站，比如github、bitbucket直接集成。 容器化布署管理Rancher在原来, 如果我们需要做一个分布式集群我们需要学习一全套的框架并编码实现如 服务发现, 负载均衡等逻辑, 给开发者造成很大的负担, 不过好在现在有Docker以及他周边的一些技术能在上层解决这些问题, 而应用该怎么开发就怎么开发.当你选择使用Docker技术栈的时候, 会发现在生产环境中不光光是 docker run就能解决的. 还需要考虑比如docker之间的组网, 缩扩容等问题, 于是你去学习kubernetes, 发现好像有点复杂啊, 有没有更傻瓜化一点的? 那就是rancher了. Rancher是一个开源的企业级容器管理平台。通过Rancher，企业再也不必自己使用一系列的开源软件去从头搭建容器服务平台。Rancher提供了在生产环境中使用的管理Docker和Kubernetes的全栈化容器部署与管理平台。 分布式日志ELK为什么用到ELK一般我们需要进行日志分析场景：直接在日志文件中 grep、awk 就可以获得自己想要的信息。但在规模较大的场景中，此方法效率低下，面临问题包括日志量太大如何归档、文本搜索太慢怎么办、如何多维度查询。需要集中化的日志管理，所有服务器上的日志收集汇总。常见解决思路是建立集中式日志收集系统，将所有节点上的日志统一收集，管理，访问。 一般大型系统是一个分布式部署的架构，不同的服务模块部署在不同的服务器上，问题出现时，大部分情况需要根据问题暴露的关键信息，定位到具体的服务器和服务模块，构建一套集中式日志系统，可以提高定位问题的效率。 一个完整的集中式日志系统，需要包含以下几个主要特点： 收集－能够采集多种来源的日志数据 传输－能够稳定的把日志数据传输到中央系统 存储－如何存储日志数据 分析－可以支持 UI 分析 警告－能够提供错误报告，监控机制 ELK提供了一整套解决方案，并且都是开源软件，之间互相配合使用，完美衔接，高效的满足了很多场合的应用。目前主流的一种日志系统。 ELK简介ELK是三个开源软件的缩写，分别表示：Elasticsearch , Logstash, Kibana , 它们都是开源软件。新增了一个FileBeat，它是一个轻量级的日志收集处理工具(Agent)，Filebeat占用资源少，适合于在各个服务器上搜集日志后传输给Logstash，官方也推荐此工具。 Elasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。 Logstash 主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为c/s架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往elasticsearch上去。 Kibana 也是一个开源和免费的工具，Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。 Filebeat隶属于Beats。目前Beats包含四种工具： Packetbeat（搜集网络流量数据） Topbeat（搜集系统、进程和文件系统级别的 CPU 和内存使用情况等数据） Filebeat（搜集文件数据） Winlogbeat（搜集 Windows 事件日志数据） 微服务实时监控Grafana随着业务的越发复杂，对软件系统的要求越来越高，这意味着我们需要随时掌控系统的运行情况。因此，对系统的实时监控以及可视化展示，就成了基础架构的必须能力。 Grafana是一个跨平台的开源的度量分析和可视化工具，可以通过将采集的数据查询然后可视化的展示，并及时通知。 1、展示方式：快速灵活的客户端图表，面板插件有许多不同方式的可视化指标和日志，官方库中具有丰富的仪表盘插件，比如热图、折线图、图表等多种展示方式； 2、数据源：Graphite，InfluxDB，OpenTSDB，Prometheus，Elasticsearch，CloudWatch和KairosDB等； 3、通知提醒：以可视方式定义最重要指标的警报规则，Grafana将不断计算并发送通知，在数据达到阈值时通过Slack、PagerDuty等获得通知； 4、混合展示：在同一图表中混合使用不同的数据源，可以基于每个查询指定数据源，甚至自定义数据源； 5、注释：使用来自不同数据源的丰富事件注释图表，将鼠标悬停在事件上会显示完整的事件元数据和标记； 6、过滤器：Ad-hoc过滤器允许动态创建新的键/值过滤器，这些过滤器会自动应用于使用该数据源的所有查询。 微服务认证JWTJSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。 跨域认证的问题互联网服务离不开用户认证。一般流程是下面这样。 1、用户向服务器发送用户名和密码。 2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。 3、服务器向用户返回一个 session_id，写入用户的 Cookie。 4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。 5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。 这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。 举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？ 一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。 另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。 JWT 的原理JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。 { &quot;姓名&quot;: &quot;张三&quot;, &quot;角色&quot;: &quot;管理员&quot;, &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot; } 以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。 服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。 JWT 的几个特点（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。 （2）JWT 不加密的情况下，不能将秘密数据写入 JWT。 （3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。 （4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 （5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 （6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 原文地址：http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html 微服务网关Zuul为什么使用zuul对外提供的服务，在无网关的情况下，API接口直接暴露给服务调用方，当调用方增多，不同业务调用方各不相同，势必需要添加定制化访问权限、校验等逻辑。当添加API网关后，再第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务端。Zuul就是提供负载均衡-反向代理-权限认证的这么一个API gateway。 ZuulZuul是Netflix开源的微服务网关，他可以和Eureka,Ribbon,Hystrix等组件配合使用。Zuul组件的核心是一系列的过滤器，这些过滤器可以完成以下功能： 身份认证和安全: 识别每一个资源的验证要求，并拒绝那些不符的请求 审查与监控： 动态路由：动态将请求路由到不同后端集群 压力测试：逐渐增加指向集群的流量，以了解性能 负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求 静态响应处理：边缘位置进行响应，避免转发到内部集群 多区域弹性：跨域AWS Region进行请求路由，旨在实现ELB(ElasticLoad Balancing)使用多样化 Spring Cloud对Zuul进行了整合和增强。目前，Zuul使用的默认是Apache的HTTP Client，也可以使用Rest Client，可以设置ribbon.restclient.enabled=true. 微服务负载均衡Spring Cloud RibbonRibbon是什么Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。 简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。 LB方案分类 目前主流的LB方案可分成两类：一种是集中式LB, 即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方； 另一种是进程内LB，将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于后者，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。 Ribbon的主要组件与工作流程 Ribbon的核心组件(均为接口类型)有以下几个： ServerList:用于获取地址列表。它既可以是静态的(提供一组固定的地址)，也可以是动态的(从注册中心中定期查询地址列表)。 ServerListFilter:仅当使用动态ServerList时使用，用于在原始的服务列表中使用一定策略过虑掉一部分地址。 IRule:选择一个最终的服务地址作为LB结果。选择策略有轮询、根据响应时间加权、断路器(当Hystrix可用时)等。 Ribbon在工作时首选会通过ServerList来获取所有可用的服务列表，然后通过ServerListFilter过虑掉一部分地址，最后在剩下的地址中通过IRule选择出一台服务器作为最终结果。 Ribbon提供的主要负载均衡策略介绍 1:简单轮询负载均衡（RoundRobin):以轮询的方式依次将请求调度不同的服务器，即每次调度执行i = (i + 1) mod n，并选出第i台服务器。 2:随机负载均衡 （Random): 随机选择状态为UP的Server 3:加权响应时间负载均衡 （WeightedResponseTime):根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。 4:区域感知轮询负载均衡（ZoneAvoidanceRule):复合判断server所在区域的性能和server的可用性选择server Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。 原文连接：http://www.cnblogs.com/senlinyang/p/8595370.html 微服务熔断Hystrixhystrix对应的中文名字是“豪猪”，豪猪周身长满了刺，能保护自己不受天敌的伤害，代表了一种防御机制，这与hystrix本身的功能不谋而合，因此Netflix团队将该框架命名为Hystrix，并使用了对应的卡通形象做作为logo。 在一个分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，如何能够保证在一个依赖出问题的情况下，不会导致整体服务失败，这个就是Hystrix需要做的事情。Hystrix提供了熔断、隔离、Fallback、cache、监控等功能，能够在一个、或多个依赖同时出现问题时保证系统依然可用。 具体参考博客：https://blog.csdn.net/ruihin/article/details/77579794 微服务集中配置Spring Cloud Config在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。 Spring Cloud Config项目是一个解决分布式系统的配置管理方案。它包含了Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用。Spring cloud使用git或svn存放配置文件，默认情况下使用git，我们先以git为例做一套示例。 服务注册与发现spring cloud eurekaSpring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。 通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。]]></content>
      <categories>
        <category>新技术</category>
      </categories>
      <tags>
        <tag>新技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网新技术]]></title>
    <url>%2F2019%2F03%2F10%2F%E4%BA%92%E8%81%94%E7%BD%91%E6%96%B0%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[这篇文章简单介绍一下目前市面上使用的互联网新技术。 职场名言： 工作首先是为了自己成长，更有竞争力，包括技能的提升，积累经验等。帮公司提升业绩，只是水到渠成的事情。 –tom叔 抱着创业的心态，动作才不会变形，一举一动更全情投入 ，抱着打工的心态，每件事只能做到六七十分，最后泯然众人矣。 –tom叔 你的工作，你的职业，是为了你自己，公司是你发挥才能的平台，自己提升和成长，展示才能，公司也会受益。职场价值观要正。以自己的成长诉求为目标，职场中的恶心事和恶心人就不会过度分散你的注意力和目标。 –曹大 下面是我从网上截取的技术点。 这里简单介绍几个技术点。 权限管理Apache ShiroApache Shiro是一个功能强大且易于使用的Java安全框架，为开发人员提供了一种直观而全面的身份验证，授权，加密和会话管理解决方案。 三个核心组件：Subject, SecurityManager 和 Realms. Spring SecuritySpring Security是一个功能强大且可高度自定义的身份验证和访问控制框架。它是保护基于Spring的应用程序的事实标准。Spring Security是一个专注于为Java应用程序提供身份验证和授权的框架。 特征 对身份验证和授权的全面和可扩展的支持 防止会话固定，点击劫持，跨站点请求伪造等攻击 Servlet API集成 可选与Spring Web MVC集成 分布式开发DubboxDubbox现在意味着是Dubbo的扩展。Dubbox为流行的dubbo服务框架添加了RESTful远程处理，Kyro / FST序列化等功能。支持基于Jackson的JSON序列化。由当当网维护。 地址：https://github.com/dangdangdotcom/dubbox 分布式文件存储FastDFSFastDFS是一个开源高性能分布式文件系统（DFS）。它的主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡的设计。FastDFS应满足基于照片共享站点和视频共享站点等文件服务的网站的要求。 FastDFS有两个角色：跟踪器和存储。跟踪器负责文件访问的调度和负载平衡。存储存储文件及其功能是文件管理，包括：文件存储，文件同步，提供文件访问接口。它还管理元数据，这些元数据表示为文件的键值对。例如：width = 1024，键为“width”，值为“1024”。 地址：https://github.com/happyfish100/fastdfs 缓存RedisRedis是一个开源（BSD许可），内存数据结构存储，用作数据库，缓存和消息代理。它支持数据结构，如字符串，散列，列表，集合，带有范围查询的排序集，位图，超级日志，具有半径查询和流的地理空间索引。Redis具有内置复制，Lua脚本，LRU驱逐，事务和不同级别的磁盘持久性，并通过Redis Sentinel提供高可用性并使用Redis Cluster自动分区。 搜索SolrSolr是基于Apache Lucene ™构建的流行，快速，开源的企业搜索平台。 Solr具有高可靠性，可扩展性和容错性，可提供分布式索引，复制和负载均衡查询，自动故障转移和恢复，集中配置等。Solr为世界上许多最大的互联网站点的搜索和导航功能提供支持。 网页静态化FreeMarkerApache FreeMarker™是一个模板引擎：一个Java库，用于根据模板和更改数据生成文本输出（HTML网页，电子邮件，配置文件，源代码等）。模板是用FreeMarker模板语言（FTL）编写的，这是一种简单的专用语言（不像PHP这样的完整编程语言）。通常，使用通用编程语言（如Java）来准备数据（发布数据库查询，进行业务计算）。然后，Apache FreeMarker使用模板显示准备好的数据。在模板中，您将专注于如何呈现数据，而在模板之外，您将关注于要呈现的数据。 消息中间件ActiveMQApache ActiveMQ ™是最受欢迎且功能最强大的开源消息传递和Integration Patterns服务器。 Apache ActiveMQ速度快，支持许多跨语言客户端和协议，带有易于使用的企业集成模式和许多高级功能，同时完全支持JMS 1.1和J2EE 1.4。Apache ActiveMQ是在Apache 2.0许可下发布的 短信阿里大于短信服务（Short Message Service）是阿里云为用户提供的一种通信服务的能力。支持国内和国际快速发送验证码、短信通知和推广短信，服务范围覆盖全球200多个国家和地区。 国内短信支持三网合一专属通道，与工信部携号转网平台实时互联。电信级运维保障，实时监控自动切换，到达率高达99%。完美支撑双11期间20亿短信发送，6亿用户触达。 单点登陆CASCAS是一种面向Web的企业多语言单点登录解决方案，它试图成为满足您的身份验证和授权需求的综合平台。 开发文档：https://apereo.github.io/cas/5.2.x/index.html 地址：https://github.com/apereo/cas 跨域jsonp跨域的安全限制都是对浏览器端来说的，服务器端是不存在跨域安全限制的。 浏览器的同源策略限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。 如果协议，端口和主机对于两个页面是相同的，则两个页面具有相同的源，否则就是不同源的。 只需配置一个dataType:’jsonp’，就可以发起一个跨域请求。 CORSCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源(协议 + 域名 + 端口)服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。它的通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 分布式idsnowflake分布式系统中，有一些需要使用全局唯一ID的场景，这种时候为了防止ID冲突可以使用36位的UUID，但是UUID有一些缺点，首先他相对比较长，另外UUID一般是无序的。 有些时候我们希望能使用一种简单一些的ID，并且希望ID能够按照时间有序生. SnowFlake算法的优点： 1.生成ID时不依赖于DB，完全在内存生成，高性能高可用。 2.ID呈趋势递增，后续插入索引树的时候性能较好。 SnowFlake算法的缺点： 依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序。 地址：https://github.com/twitter-archive/snowflake 开发与生产环境切换Maven profileProfile能让你为一个特殊的环境自定义一个特殊的构建； profile使得不同环境间构建的可移植性成为可能。Maven中的profile是一组可选的配置，可以用来设置或者覆盖配置默认值。有了profile，你就可以为不同的环境定制构建。profile可以在pom.xml中配置，并给定一个id。然后你就可以在运行Maven的时候使用的命令行标记告诉Maven运行特定profile中的目标。 集群部署分布式系统协调ZooKeeperZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 分布式搜索SolrCloudSolrCloud是基于Solr和Zookeeper的分布式搜索方案。 当索引越来越大，一个单一的系统无法满足磁盘需求，查询速度缓慢，此时就需要分布式索引。在分布式索引中，原来的大索引，将会分成多个小索引，solr可以将这些小索引返回的结果合并，然后返回给客户端。 负载均衡NginxNginx (engine x) 是一个高性能的HTTP和反向代理服务，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。 其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。 海量数据存储解决方案MycatMycat是数据库分库分表中间件。基于阿里开源的Cobar产品而研发。 一个彻底开源的，面向企业应用开发的大数据库集群 支持事务、ACID、可以替代MySQL的加强版数据库 一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群 一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server 结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品 一个新颖的数据库中间件产品 地址：https://github.com/MyCATApache/Mycat-Server 容器化部署DockerDocker 是世界领先的软件容器平台。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。运维人员利用 Docker 可以在隔离容器中并行运行和管理应用，获得更好的计算密度。企业利用 Docker 可以构建敏捷的软件交付管道，以更快的速度、更高的安全性和可靠的信誉为 Linux 和 Windows Server 应用发布新功能。 有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效、轻量、自给自足，还能保证部署在任何环境中的软件都能始终如一地运行。]]></content>
      <categories>
        <category>新技术</category>
      </categories>
      <tags>
        <tag>新技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式session问题]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%88%86%E5%B8%83%E5%BC%8Fsession%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近这几天一直在研究nginx负载均衡服务器，也实现了通过nginx服务器把用户的请求分发到了不同的tomcat上。但随之也遇到了一个问题，就是如何不同tomcat之间的session同步问题。 以前我们通常是单台tomcat部署一个小应用，请求量也不是很高，所以没有采用nginx服务器负载，这时候用户的请求都是由这一台tomcat服务器处理，所以不存在用户sesson不同步的情况。 现在随着业务拓展，用户量的增加，导致单一的tomcat不足以支撑整个业务，所以采用tomcat集群来处理用户的高并发需求，用nginx来做负载均衡。但是不同的tomcat之间信息不互通，这就有问题了。假如用户请求通过nginx分发到tomcat集群中一台服务器，登陆了系统，然后用户又发起另一个请求，通过nginx的分发，恰巧分到了没有登陆过的tomcat上了，这时，用户则又需要登陆一次。假设每次请求都恰巧分到了没有登陆过的服务器，那对于用户来说，这体验简直是糟糕透了。 所以急需解决tomcat集群中session同步问题，也就是分布式session问题。网上有几种解决方案，但最流行的则是通过redis缓存来解决。 以我的理解来说，这种解决方案就是 当用户登陆时，首先去redis服务器中查找用户的jsessionid，如果存在，则直接取出用户的session信息。如果不村在，则把用户的jsessionid作为redis的key, session信息作为 value存储在redis数据库中。每当有请求过来时，总会查询一次内存数据库，判断用户是否存在，这样就解决了分布式session问题。 不知道理解的对不对，欢迎大佬们指正。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定制NexT主题]]></title>
    <url>%2F2018%2F10%2F04%2F%E5%AE%9A%E5%88%B6NexT%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[简介:Hexo 是高效的静态站点生成框架，她基于 Node.js。在前面安装好这个框架后，我们可以选择多套主题来展示我们的博客样式风格。这里是这个框架包含的主题样式。本案例采用nexT主题风格，可以参考官方使用文档。当你看到这篇博客的风格时，这就是所谓nexT主题了！ 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。 安装 NexTHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。 下载主题如果你熟悉 Git， 建议你使用 克隆最新版本 的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。 在终端窗口下，定位到 Hexo 站点目录下。右键选择 Git Bash，执行以下命令。 git clone https://github.com/iissnan/hexo-theme-next themes/next 如果你对 Git 感兴趣，可以参考这个在线文档。 启用主题打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 theme: next 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 验证主题首先启动 Hexo 本地站点，命令是 hexo s。 使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 当你看到页面出现内容时，说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse 主题设定选择 SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持四种 Scheme，他们是： Muse 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist Muse 的紧凑版本，整洁有序的单栏外观 Pisces 双栏 Scheme，小家碧玉似的清新 Gemini 与Pisces类似，布局风格不同 Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有四行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。 # Schemes #scheme: Muse #scheme: Mist #scheme: Pisces scheme: Gemini 设置 语言编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下： language: zh-Hans 设置 菜单菜单配置包括两个部分，第一是菜单项（名称和链接）菜单项对应的图标，第二是菜单项的显示文本。 编辑 主题配置文件，修改以下内容： 设定菜单内容对应的字段是 menu。 菜单内容的设置格式是：item name: link || icon name。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。icon name 该菜单显示的图标名称。可以在 menu_icons: enable: true 这里关闭图标，把true改为false即可 菜单示例配置 menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 设置菜单项的显示文本在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在 menu 字段下添加一项： menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 设置 头像编辑 主题配置文件， 修改字段 avatar， 值设置成头像的链接地址。把头像图片放置在 source/images/ 目录下配置为：avatar: /images/avatar.png 设置 作者昵称编辑 站点配置文件， 设置 author 为你的昵称。 站点描述编辑 站点配置文件， 设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名:) 主题配置NexT 坚持将复杂的细节隐藏，提供尽量少并且简便的设置，保持最大限度的易用性。 添加「标签」页面新建「标签」页面，并在菜单中显示「标签」链接。「标签」页面将展示站点的所有标签，若你的所有文章都未包含标签，此页面将是空的。 底下代码是一篇包含标签的文章的例子： title: 标签测试文章 tags: - Testing - Another Tag --- 新建页面在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 tags ： hexo new page tags 设置页面类型编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下： title: 标签 date: 2018-10-04 12:39:04 type: &quot;tags&quot; --- 修改菜单在菜单中添加链接。编辑 主题配置文件 ， 添加 tags 到 menu 中，如下: menu: home: / archives: /archives tags: /tags 注意：如果有集成评论服务，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false，如： title: 标签 date: 2018-10-04 12:39:04 type: &quot;tags&quot; comments: false --- 添加「分类」页面新建「分类」页面，并在菜单中显示「分类」链接。「分类」页面将展示站点的所有分类，若你的所有文章都未包含分类，此页面将是空的。 底下代码是一篇包含分类的文章的例子： title: 分类测试文章 categories: Testing --- 新建页面在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories ： hexo new page categories 设置页面类型编辑刚新建的页面，将页面的 type 设置为 categories ，主题将自动为这个页面显示分类。页面内容如下： title: 分类 date: 2018-10-04 12:39:04 type: &quot;categories&quot; --- 修改菜单在菜单中添加链接。编辑 主题配置文件 ， 添加 categories 到 menu 中，如下: menu: home: / archives: /archives categories: /categories 注意如果有集成评论服务，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false，如： title: 分类 date: 2018-10-04 12:39:04 type: &quot;categories&quot; comments: false --- 侧边栏社交链接侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在 主题配置文件 中。 链接 || 图标链接放置在 social 字段下，一行一个链接。其键值格式是 显示文本: 链接地址 || 链接的图标。 配置示例： social: GitHub: https://github.com/your-user-name || github 微博: http://weibo.com/your-user-name || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter 开启打赏功能 只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址 即可开启该功能。 打赏功能配置示例 reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！ wechatpay: /images/wechat-reward-image alipay: /images/alipay-reward-image 二维码可以放在主题文件 source\images下 友情链接编辑 主题配置文件 添加： # title links_title: Links links: MacTalk: http://macshuo.com/ Title: http://example.com/ 腾讯公益404页面腾讯公益404页面，寻找丢失儿童，让大家一起关注此项公益事业！效果如下 http://www.ixirong.com/404.html 使用方法，新建 404.html 页面，放到主题的 source 目录下，内容如下： &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot; homePageName=&quot;回到我的主页&quot;&gt; &lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 更改主题配置文件的 menu 菜单链接 menu: home: / || home commonweal: /404.html || heartbeat 站点建立时间这个时间将在站点的底部显示，例如 © 2013 - 2015。 编辑 主题配置文件 配置示例： footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2018 订阅微信公众号在每篇文章的末尾显示微信公众号二维码，扫一扫，轻松订阅博客。 在微信公众号平台下载您的二维码，并将它存放于博客source/uploads/目录下。 然后编辑 主题配置文件，如下： wechat_subscriber: enabled: true qcode: /uploads/wechat-qcode.jpg description: 欢迎您扫一扫上面的微信公众号，订阅我的博客！ 设置「背景动画」NexT 自带两种背景动画效果 编辑 主题配置文件， 搜索 canvas_nest 或 three_waves，根据您的需求设置值为 true 或者 false 即可：canvas_nest 配置示例： # Canvas-nest canvas_nest: true 第三方服务集成静态站点拥有一定的局限性，因此我们需要借助于第三方服务来扩展站点的功能。 以下是 NexT 目前支持的第三方服务，你可以根据你的需求集成一些功能进来。 评论系统NexT 支持多款评论系统。 如需取消某个 页面/文章 的评论，在 md 文件的 front-matter 中增加 comments: false 我们这里采用Valine作为自己的评论。这里是官方文档介绍 这个评论系统是基于LeanCloud的，Hexo的博客阅读量统计也是它,官网网址如下，需要注册一个账户。这里是官网链接，可以直接进行注册。LeanCloud官网 获取APP ID 和 APP Key进入控制台后点击左下角创建应用：名字随便起，后面可以更改。 应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了： 配置valine拿到你的appid和appkey之后，打开主题配置文件 搜索 valine，填入appid 和 appkey valine: enable: true appid: your app id appkey: your app key notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 这里可以自己填写内容 guest_info: nick,mail,link pageSize: 10 安全域名为了你的数据安全，请设置自己的安全域名： 这里填写自己的网站名即可。 数据统计与分析不蒜子统计全局配置编辑 主题配置文件 中的busuanzi_count的配置项。 编辑 主题配置文件 中的busuanzi_count的配置项。 当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。 站点UV配置当site_uv: true时，代表在页面底部显示站点的UV值。 site_uv_header和site_uv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[site_uv_header]UV值[site_uv_footer]。 # 效果：本站访客数12345人次 site_uv: true site_uv_header: 本站访客数 site_uv_footer: 人次 站点PV配置当site_pv: true时，代表在页面底部显示站点的PV值。 site_pv_header和site_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[site_pv_header]PV值[site_pv_footer]。 # 效果：本站总访问量12345次 site_pv: true site_pv_header: 本站总访问量 site_pv_footer: 次 页面PV配置当page_pv: true时，代表在文章页面的标题下显示该页面的PV值（阅读数）。 page_pv_header和page_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[page_pv_header]PV值[page_pv_footer]。 # 效果：本文总阅读量12345次 page_pv: true page_pv_header: 本文总阅读量 page_pv_footer: 次 注意该统计仅仅在页面展示，并没有后台相关的数据，如果想要查看实时统计数据，需要接入百度统计功能 百度统计1.登录 百度统计，如果没有就注册一个，选择站长类型 2.新增网站管理,填写自己的域名。 3.找到代码获取菜单 4.复制 hm.js? 后面那串统计脚本 id，如下图所示： 5.编辑 主题配置文件， 修改字段 baidu_analytics，值设置成你的百度统计脚本 id。 # Baidu Analytics ID baidu_analytics: 你复制的脚本id 6.代码安装检查 点击开始检查即可，如果没有问题就会提示：代码安装正确。 7.可以自己先把网站部署好，然后自己多访问几次，可以用wifi尝试，然后用流量访问。目的就是可以模拟不同ip的用户访问。 8.单击报告，就可以查看网站的实时访客，流量分析，访客分析等数据。 搜索服务NexT 支持集成 Swiftype、 微搜索、Local Search 和 Algolia。 这里采用Local Search,自定义站点内容搜索 1.安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： npm install hexo-generator-searchdb --save 2.编辑 站点配置文件，新增以下内容到任意位置： search: path: search.xml field: post format: html limit: 10000 3.编辑 主题配置文件，启用本地搜索功能： # Local search local_search: enable: true DaoVoice 在线联系首先去注册，这里是官网, 注册时需要邀请码，贴一个435a515a，或者直接点击邀请码的链接。注册后就可以查看你的app_id: 复制app_id，打开/themes/next/layout/_partials/head.swig,在末尾写下如下代码： 点击这里获取代码 接着打开主题配置文件，在最后写下如下代码： # Online contact daovoice: true daovoice_app_id: your app_id 具体样式设计可以在 应用设置–&gt;聊天设置 后边改。 文章阅读次数统计(LeanCloud)在注册完成LeanCloud帐号并验证邮箱之后，我们就可以登录我们的LeanCloud帐号，进行一番配置之后拿到AppID以及AppKey这两个参数即可正常使用文章阅读量统计的功能了。 按照下图操作创建Counter的class，该Class就可以存放我们文章的阅读次数。 复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子: # Show number of visitors to each article. # You can visit https://leancloud.cn get AppID and AppKey. leancloud_visitors: enable: true app_id: your app_id app_key: your app_key 这个时候重新生成部署Hexo博客，应该就可以正常使用文章阅读量统计的功能了。 注意记录文章访问量的唯一标识符是文章的发布日期以及文章的标题，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计。 如果删除了某一篇文章，要找到后台删除对应这篇文章的统计记录. 右上角的Github样式实现效果有两种： 具体实现方式便是到样式1或者样式2的网站中选择你喜欢的样式，复制其中的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址。 当前位置百分比效果当滑动鼠标滚轮时,右下角有一个向上的箭头,该箭头的百分比代表你当前所处页面的位置大小。 编辑 主题配置文件，找到scrollpercent属性，设置为true # Scroll percent label in b2t button. scrollpercent: true 其他细节鼠标点击产生爱心效果创建js文件在/themes/next/source/js/src下新建文件love.js 然后复制以下代码到love.js文件中 !function(e,t,a){function n(){c(&quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)}function o(){var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),i(e)}}function i(e){var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)}function s(){return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document); 修改_layout.swig在\themes\next\layout_layout.swig文件末尾添加： &lt;!-- 页面点击小红心 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 修改文章底部标签样式打开/themes/next/layout/_macro/post.swig文件 搜索 rel=”tag”&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 阅读排行榜设置新建页面hexo n page top 新建页面，会生成 top 目录，编辑其中自动生成的 index.md 文件，将其中的代码替换如下： &lt;div id=&quot;top&quot;&gt;&lt;/div&gt; &lt;script src=&quot;https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js&quot;&gt;&lt;/script&gt; &lt;script&gt;AV.initialize(&quot;leancloud_appid&quot;, &quot;leancloud_appkey&quot;);&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var time=0 var title=&quot;&quot; var url=&quot;&quot; var query = new AV.Query(&apos;Counter&apos;); query.notEqualTo(&apos;id&apos;,0); query.descending(&apos;time&apos;); query.limit(1000); query.find().then(function (todo) { for (var i=0;i&lt;1000;i++){ var result=todo[i].attributes; time=result.time; title=result.title; url=result.url; var content=&quot;&lt;p&gt;&quot;+&quot;&lt;font color=&apos;#1C1C1C&apos;&gt;&quot;+&quot;【文章热度:&quot;+time+&quot;℃】&quot;+&quot;&lt;/font&gt;&quot;+&quot;&lt;a href=&apos;&quot;+&quot;你的博客地址&quot;+url+&quot;&apos;&gt;&quot;+title+&quot;&lt;/a&gt;&quot;+&quot;&lt;/p&gt;&quot;; document.getElementById(&quot;top&quot;).innerHTML+=content } }, function (error) { console.log(&quot;error&quot;); }); &lt;/script&gt; 并将其中的 leancloud_appid、leancloud_appkey 和页面链接替换为你的。 配置菜单显示编辑主题配置文件 themes\next_config.yml，添加 top： menu: home: / || home top: /top/ || signal 添加中文显示打开hexo/theme/next/languages/zh-Hans.yml，新增 top 对应的中文 menu: home: 首页 top: 阅读排行 注意如果删除了一篇文章，那么要登陆LeanCloud的控制台，找到 存储-&gt;Counter 在右边展示的列表中删除对应这篇博客的阅读数量记录。 鼠标悬停头像自动旋转打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl 在里面添加如下代码： .site-author-image { display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out; } .site-author-name { margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight; } .site-description { margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color; } img:hover { /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg); } /* Z 轴旋转动画 */ @-webkit-keyframes play { 0% { -webkit-transform: rotateZ(0deg); } 100% { -webkit-transform: rotateZ(-360deg); } } @-moz-keyframes play { 0% { -moz-transform: rotateZ(0deg); } 100% { -moz-transform: rotateZ(-360deg); } } @keyframes play { 0% { transform: rotateZ(0deg); } 100% { transform: rotateZ(-360deg); } } 字数统计用于统计文章的字数以及分析出阅读时间。 在主题配置文件中，搜索wordcount，设置为下面这样就可以了： # Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount post_wordcount: item_text: true min2read: true wordcount: true totalcount: true separated_meta: true 文章结束标志新建passage-end-tag.swig文件在路径\themes\next\layout_macro中新建passage-end-tag.swig文件,并添加以下内容： 点击这里获取代码 其中 font-size:14px，数字越大，代表页面显示结束标志的字体就越大。 修改 post.swig 文件在 \themes\next\layout_macro\post.swig中， post-body之后， post-footer之前添加如下代码（post-footer之前两个DIV） &lt;div&gt; {% if not is_index %} {% include 'passage-end-tag.swig' %} {% endif %} &lt;/div&gt; 修改主题配置文件在主题配置文件 _config.yml中添加以下字段开启此功能： # 文章末尾添加“本文结束”标记 passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会添加“本文结束”标记。 文章版权设置打开主题配置文件_config.yml，搜索post_copyright，修改为： # Declare license on posts post_copyright: enable: true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 打开站点配置文件，搜索url,把地址改为自己的博客地址即可： # URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: 你的博客地址 root: / permalink: :year/:month/:day/:title/ #permalink: :title/ permalink代表博客生成文章的链接目录，如果想要访问路径简洁些，可以注释掉当前的路径生成方式，启用下面的只含文章标题的生成方式。 网站底部版权信息网站的底部会显示框架hexo的信息，以及你使用的NexT的主题信息，如何去掉显示，按照下面设置即可： copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false 网站logo设置打开主题配置文件，搜索favicon，按照如下配置： favicon: small: /images/blog-16x16.png medium: /images/blog-32x32.png 把你自己想要展示的logo图片放在themes\next\source\images目录下即可。图片需要放两张，一张为16x16像素，一张32x32像素。注意图片名称与路径设置的要一致。]]></content>
      <categories>
        <category>博客教程</category>
      </categories>
      <tags>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>博客教程</category>
      </categories>
      <tags>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何发布博客文章]]></title>
    <url>%2F2018%2F10%2F03%2F%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[本教程教大家如何发布自己的博客文章！ 还没有搭建好博客环境的可以参考这篇文章 搭建个人博客 最近是国庆假期，祝大家国庆快乐！ 环境准备博客生成的文章都是以md结尾的，这种文件推荐使用专业支持Markdown语法的编辑器进行打开编辑，例如Windows平台的MarkdownPad可以支持文章的实时预览，效果出众。下面的截图就是安装好的MarkdownPad 2。 下载编辑工具MarkdownPad官方下载连接 MarkdownPad 找到下面截图的位置，然后下载，进行安装。 配置MarkdownPad破解 邮件地址 Soar360@live.com 授权证书 GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 破解成功！ 简体中文设置点击TOOLS–Options-editor-Application Language-中文简体 HTML无法渲染点击预览按钮时，提示html无法渲染问题。 解决方案:下载awesomium 官方地址awesomium，找到下图的位置，点击下载安装即可。 开始发布文章给博客添加图片博客有时候需要添加图片说明，才能让文章通俗易懂。 解决方案： 1.在安装Hexo的目录下的_config.yml里的psot_asset_folder:设置为true 2.在安装Hexo的目录下右键选择 Git Bash，执行以下命令 npm install hexo-asset-image --save 安装成功后，在运行hexo n “博客名”来生成md博客时，会在_post目录下看到一个与博客同名的文件夹。 将想要上传的图片先扔到文件夹下，然后在博客中使用markdown的格式引入图片： ![](xxxx/图片名.jpg) 因为博客名和文件夹名字相同，所以不需要绝对路径，只要xxxx是文件夹的名字就可以了。 创建文章在安装Hexo的目录下右键选择 Git Bash hexo n &quot;如何发布博客文章&quot; 双引号内为文章的标题名，可以根据自己的需求自行改动。 这时就会在博客目录下source_posts中生成相应的 如何发布博客文章.md文件,如果你执行了上面添加图片的命令的话，可以看到同时生成了一个同名的文件夹，如果需要添加图片，直接放在这里面，然后在博客内引用即可。 编辑文章对于刚刚产生的md格式的文件，我们就可以用安装好的MarkdownPad来打开。在编辑文章的同时，可以在浏览器预览当前的编辑内容。 这里放一些MarkdownPad常用语法，供大家参考当然也可以用编辑器自带的工具栏快速编辑文章 标题# 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 字体**这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 图片语法：![图片alt](图片地址 &quot;图片title&quot;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 超链接语法：[超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加 代码语法： 单行代码：代码之间分别用一个反引号包起来 `代码内容` 代码块 function fun(){ echo &quot;这是一句非常牛逼的代码&quot;; } 语法:在代码块后面回车，然后按一个tab键，即可编写代码块 本地预览编辑完成后就可以进行本地预览 hexo g hexo s hexo g 生成本地html文件，hexo s 开启本地服务，可以在localhost:4000查看当前编写的文章。 发布hexo d 将本文推送到github上，然后就可以访问了。]]></content>
      <categories>
        <category>博客教程</category>
      </categories>
      <tags>
        <tag>next主题</tag>
      </tags>
  </entry>
</search>
